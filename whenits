#!/usr/bin/perl

# (c) 2017 Jim Salter. Licensed GPLv3.

# whenits [unixtime] [command] - execute the given command when the system reaches the unix time specifed as the first argument.

# this software is licensed for use under the Free Software Foundation's GPL v3.0 license, as retrieved
# from http://www.gnu.org/licenses/gpl-3.0.html on 2014-11-17.  A copy should also be available in this
# project's Git repository at https://github.com/jimsalterjrs/network-testing/blob/master/LICENSE.


use Time::HiRes qw ( usleep gettimeofday );
use POSIX 'setsid';

daemonize();

my $exectime = $ARGV[0];

my ($seconds,$microseconds) = gettimeofday();
my $currenttime = "$seconds." . sprintf ("%.06d", $microseconds);
my $usleeptime = ($exectime - $currenttime) * 1000000;

# low cpu power sleep cycle. wake up 200ms early for a higher-power, more accurate wait cycle.
$usleeptime -= 200000;
if ($usleeptime>0) { usleep $usleeptime; }

# high power wait cycle. more accurate than usleep
my $time = time();
while ($time < $exectime) { $time = time() };

# Time to wake up now!
my @args = @ARGV;
shift @args;
exec @args;

exit 0;

sub daemonize {
	# fork and run in the background, let foreground parent die.

	# I don't wanna chdir /, that'll break ./ commands!
	# chdir '/'               	or die "Can't chdir to /: $!";

	open STDIN, '/dev/null' 	or die "Can't read /dev/null: $!";
	open STDOUT, '>/dev/null'	or die "Can't write to /dev/null: $!";
	defined(my $pid = fork) 	or die "Can't fork: $!";
	exit if $pid;
	setsid                  	or die "Can't start a new session: $!";
	open STDERR, '>&STDOUT' 	or die "Can't dup stdout: $!";
}
