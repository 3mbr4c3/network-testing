#!/usr/bin/perl

# (c) 2017 Jim Salter. Licensed GPLv3.

# this software is licensed for use under the Free Software Foundation's GPL v3.0 license, as retrieved
# from http://www.gnu.org/licenses/gpl-3.0.html on 2014-11-17.  A copy should also be available in this
# project's Git repository at https://github.com/jimsalterjrs/network-testing/blob/master/LICENSE.

use strict;
use Config::IniFiles;   # read samba-style conf file
use Data::Dumper;       # debugging - print contents of hash
use Time::HiRes qw ( usleep );

my $conf_file = './net-hydra.conf';
my $sshcmd = '/usr/bin/ssh';

# load test configs from multiclient.conf
tie my %ini, 'Config::IniFiles', ( -file => $conf_file ) or die "FATAL: cannot load $conf_file.";

# populate %devices from $ini{'devices'} for easier access later
my %devices;
my %directives;
foreach my $device (keys %{ $ini{'devices'} }) {
	$devices{$device} = $ini{'devices'}{$device};
}


# establish SSH control sessions for each device
foreach my $device (sort keys %devices) { 
	my $socket = "/tmp/multiclient-$device-" . time();
	open FH, "$sshcmd -M -S $socket -o ControlPersist=5m $devices{$device} exit |";
	close FH;
}

# establish clock is synced at each device
foreach my $device (sort keys %devices) { 
	my $cmd = "/bin/date +%s";
	my $now = time();
	my $sync = `$sshcmd $devices{$device} $cmd`;
	if ( abs($now - $sync) <2 ) {
		print "Device $device at $devices{$device} is in sync with me.\n";
	} else {
		my $delta = $now-$sync;
		print "Device $device at $devices{$device} is $delta seconds off from my clock.\n";
	}
}

# we'll execute on the client systems in ten seconds
my $when = time()+10;

# populate %devices from $ini{'devices'} for easier access later
foreach my $device (keys %{ $ini{'directives'} }) {
	$directives{$device} = $ini{'directives'}{$device};
	if ($directives{$device} =~ /^\$/) {
		# it's an alias, so populate it from the aliases table
		$directives{$device} = $ini{'aliases'}{$directives{$device}};
	}
	# substitute exection time in for special value $when in the directives
	$directives{$device} =~ s/\$when/$when/g;
}

# loop through the directives given
foreach my $device (sort keys %directives) {
	#print "$device is at $devices{$device} and needs to whenits $when $directives{$device} .\n";
	my $cmd = "$sshcmd root\@$devices{$device} whenits $when $directives{$device}";
	print "$cmd\n";
	system $cmd;
}

my $now=time();
print "Executing on client systems in " . ($when-$now) . " seconds...\n";
while ($now < $when) { 
	$now = time(); 
        # move 1 line up, clear to beginning of that line
        print "\e[1F";
        print "\e[K";
	print "Executing on client systems in " . ($when-$now) . " seconds...\n";
	usleep 100000; # sleep 100 milliseconds
}

print "\e[1F";
print "\e[K";
print "Client systems executing now.\n";
	
exit 0;
